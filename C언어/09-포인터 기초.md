# 포인터 기초

## 1. 포인터의 개요
포인터는 데이터나 프로그램이 저장되어 있는 메모리 주소를 지정하는 변수를 의미한다.

변수를 선언하면 컴파일러와 운영체제가 알아서 메모리 주조를 저장했다가 호출하면 가져오기 때문에 변수를 선언할 때 메모리 주소를 일일이 지정해 주지 않아도 된다.

변수를 선언하면 메모리 공간이 자료형의 크기 만큼 확보된다.

ex) int형은 4바이트, char형은 1바이트, float형은 4바이트, double형은 8바이트 크기를 메모리 공간으로부터 확보한다.

### 주소 참조 연산자
포인터를 사용할 떄 꼭 알아야 하는 연산자가 바로 주소 참조 연산자이다.

주소 참조 연산자는 &(엠퍼샌드)를 사용한다.

&는 변수를 선언하고 변수에 대입한 값이 저장되어 있는 메모리 주소를 반환한다.
<pre>주소 참조 연산자로 변수의 주소 출력
<code>
#include<stdio.h>

int main(void)
{
	int i_num = 3;
	char ch = 'A';
	float f_num = 21.5;

	printf("변수의 메모리 상의 주소를 10진수로 출력 \n");		
	printf("1. i_num의 주소 : %p\n", &i_num);
	printf("2. ch의 주소 : %p\n", &ch);
	printf("3. f_num의 주소 : %p\n", &f_num);

	printf("\n 변수에 저장된 데이터 값을 출력 \n");
	printf("1. i_num : %d\n", i_num);
	printf("2. ch : %c\n", ch);
	printf("3. f_num : %.1f\n", f_num);
	return 0;
}</code></pre>
'&변수명'으로 선언하면 변수에 할단된 메모리 주소를 출력할 수 있다.

메모리에 저장되어 있는 변수값의 주소를 반환하려면 주소 참조 연산자인 &를 변수명 앞에 선언하여 출력해야 한다.

## 2. 포인터 사용

### 포인터 선언과 초기화
<pre>포인터 선언
<code>
int *변수명;     // 정수형 포인터
char *변수명;    // 문자형 포인터
float *변수명;   // 실수형 포인터</code></pre>
포인터를 선언할 때도 일반 변수와 같이 변수명 앞에 자료형을 선언해 준다.

다만, 변수명 앞에 포인터를 의미하는 *(애스터리스크)를 붙여준다는 점만 다르다.

<pre>상대 주소값으로 포인터 초기화
<code>
int a = 8;  // 정수형 변수 a를 선언하고 8의 값으로 초기화
int *p;     // 포인터 *p 선언
p = &a;     // 포인터 p에 일반 변수 a의 주소값 대입 </code></pre>
일반 변수 a에 대입한 값이 메모리 주소의 2번지에 저장되었다고 가정할 때 p = &a를 실행하면 
포인터 p에는 일반 변수 a의 주소값이 대입된다.

따라서 p = 2의 값을 가지게 된다.

### 간접 참조 연산자

<pre>간접 참조 연산자
<code>
int a = 8;    // 정수형 변수 a선언 후 8의 값으로 초기화
int *p;       // 포인터 *p 선언
p = &a;       // 포인터 p에 일반 변수 a의 주소값 대입
printf("%d\n", *p); // 주소값이 아닌 데이터값 출력 </code></pre>
간접 참조 연산자는 포인터 앞에 *를 붙여 포인터가 가리키는 주소에 저장된 데이터값을 반환할 때 사용하는 연산자이다.

간접으로 참조한다는 의미는 포인터가 가리키는 주소를 가져오는 것이 아니고 그 주소에 저장된 데이터값을 불러온다는 의미이다.

위의 코드를 실행하면 8이 출려된다.

<pre>포인터
<code>
#include<stdio.h>

int main(void)
{
	int x = 100, y = 200;
	int* p;

	p = &x;
	printf("p = %p \n", p);
	printf("*p = %d\n\n", *p);

	p = &y;
	printf("p= %p\n", p);
	printf("*p = %d\n", *p);
	return 0;
}</code></pre>
p와 *p에 따라 출력 결과값이 달라지는 것을 볼 수 있다.

p는 주소값을 출력하고, *p는 그 주소에 있는 데이터값을 출력한다.

## 3. 포인터 연산

### 포인터 타입별 증감 연산
포인터 증감 연산은 일반 연산처럼 증감값 1을 더하거나 빼라는 것이 아니다.

포인터를 선언한 자료형의 크기만큼 더하거나 빼라는 의미이다.

포인터 증감 연산은 포인터가 가리키는 주소에 저장된 자료형의 크기만큼 증감한다.

char *p 라고 선언하고, *p++ 또는 *p--는 1씩 증가 또는 감소한다.

int *p 라고 선언하고, *p++ 또는 *p--는 4씩 증가 또는 감소한다.

따라서 자료형의 크기만큼 증감하는 것을 알 수 있다.

### 포인터 증감 연산과 메모리 주소

포인터 증감 연산자 활용 예시

*p++ 는 ++의 우선순위가 *보다 높지만 뒤에 선언되었기 때문에 *p를 먼저 수행한 후 p++을 수행하여 주소값 1 증가

(*p)++ 는 괄호 안에 있는 *연산자를 먼저 수행하고 포인터 p가 가리키는 주소의 데이터값을 1 증가

*++p 는 *보다 ++의 우선순위가 높으므로 포인터 p가 가리키는 주소값을 먼저 증가시키고 변동된 주소에 저장되어 있는 데이터값을 참조한다.

++*p 는 포인터 p가 가리키는 주소의 데이터값을 1 증가시킨다음 그 데이터값을 참조한다.

## 4. 포인터와 배열
포인터와 배열은 매우 밀접한 관계를 가지고 있다.

포인터와 배열의 관계에서 배열 이름 자체는 포인터와 동일한 기능을 수행한다. (주소를 저장하고 있다.)

즉 배열의 이름은 첫 번째 배열 요소를 가리키는 포인터와 같다.

<pre>
<code>
#include<stdio.h>			

int main(void)
{
	int a[] = { 10, 20, 30, 40, 50 };

	printf("&a[0] = %p\n", &a[0]);
	printf("&a[1] = %p\n", &a[1]);
	printf("&a[2] = %p\n", &a[2]);

	printf("a = %p\n", a);

	return 0;
}</code></pre>
인덱스 0번의 주소와 배열의 시작 주소가 같은 모습을 볼 수 있다.

